<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <meta content='width=device-width, initial-scale=1' name='viewport'>
    <meta content='IE=edge' http-equiv='X-UA-Compatible'>
    <meta content='no' name='msapplication-tap-highlight'>
    <meta content='Aparapi is an Open-source framework for executing native Java code on the GPU, developed by Syncleus.' name='description'>
    <title>
      Aparapi | NewFeatures
    </title>
    <!-- Favicons -->
    <link href='/images/favicon/apple-touch-icon-152x152.png' rel='apple-touch-icon-precomposed'>
    <meta content='#FFFFFF' name='msapplication-TileColor'>
    <meta content='/images/favicon/mstile-144x144.png' name='msapplication-TileImage'>
    <link href='/images/favicon/favicon-32x32.png' rel='icon' sizes='32x32'>
    <!-- Android 5 Chrome Color -->
    <meta content='#EE6E73' name='theme-color'>
    <!-- CSS -->
    <link href='/stylesheets/highlight.css' media='screen,projection' rel='stylesheet' type='text/css'>
    <link href='/stylesheets/style.css' media='screen,projection' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/icon?family=Material+Icons' rel='stylesheet'>
  </head>
  <body>
    <header>
      <div class='container'>
        <a class='button-collapse top-nav waves-effect waves-light circle hide-on-large-only' data-activates='nav-mobile' href='#'>
          <i class='material-icons'>menu</i>
        </a>
      </div>
      <ul class='side-nav fixed' id='nav-mobile'>
        <li class='logo'>
          <a class='brand-logo' href='/' id='logo-container'>
            <object data='/images/logo.svg' id='front-page-logo' type='image/svg+xml'>Your browser does not support SVG</object>
          </a>
        </li>
        <li class='search'>
          <div class='search-wrapper card'>
            <input id='search'>
            <i class='material-icons'>search</i>
            <div class='search-results'></div>
          </div>
        </li>
        <li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/">Overview</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/showcase.html">Showcase</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a class='collapsible-header waves-effect waves-teal'>Introduction</a><div class='collapsible-body'><ul><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/introduction/about.html">About</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/introduction/getting-started.html">Getting Started</a></li></ul></li></ul></div></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a class='collapsible-header waves-effect waves-teal'>Documentation</a><div class='collapsible-body'><ul><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/AccessingMultiDimNDRangeProposal.html">AccessingMultiDimNDRangeProposal</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/AddingLambdasToAparapi.html">AddingLambdasToAparapi</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/AddressSpacesUsingBuffers.html">AddressSpacesUsingBuffers</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/AparapiExtensionProposal.html">AparapiExtensionProposal</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/AparapiPatterns.html">AparapiPatterns</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/BuildingNBody.html">BuildingNBody</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/ChoosingSpecificDevicesForExecution.html">ChoosingSpecificDevicesForExecution</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/ConvertingBytecodeToOpenCL.html">ConvertingBytecodeToOpenCL</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/DeviceProposal.html">DeviceProposal</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/EmulatingMultipleEntrypointsUsingCurrentAPI.html">EmulatingMultipleEntrypointsUsingCurrentAPI</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/ExplicitBufferHandling.html">ExplicitBufferHandling</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/FrequentlyAskedQuestions.html">FrequentlyAskedQuestions</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/HSAEnablementOfLambdaBranch.html">HSAEnablementOfLambdaBranch</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/HSAEnablementOfLambdaBranchSidebar.html">HSAEnablementOfLambdaBranchSidebar</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/JavaKernelGuidelines.html">JavaKernelGuidelines</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/LIbraryAgentDuality.html">LIbraryAgentDuality</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/MultipleEntryPointSupportProposal.html">MultipleEntryPointSupportProposal</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/NewFeatures.html">NewFeatures</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/NewOpenCLBinding.html">NewOpenCLBinding</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/PossibleAparapiLambdaSyntaxOptions.html">PossibleAparapiLambdaSyntaxOptions</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/PrivateMemorySpace.html">PrivateMemorySpace</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/ProfilingKernelExecution.html">ProfilingKernelExecution</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/ProfilingKernelsFromEclipse.html">ProfilingKernelsFromEclipse</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/SettingUpLinuxHSAMachineForAparapi.html">SettingUpLinuxHSAMachineForAparapi</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/SettingUpLinuxHSAMachineForAparapiSidebar.html">SettingUpLinuxHSAMachineForAparapiSidebar</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/UnitTestGuide.html">UnitTestGuide</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/UsingAparapiLambdaBranchWithHSASimulator.html">UsingAparapiLambdaBranchWithHSASimulator</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/UsingConstantMemory.html">UsingConstantMemory</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/UsingLocalMemory.html">UsingLocalMemory</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/UsingMultiDimExecutionRanges.html">UsingMultiDimExecutionRanges</a></li></ul></li></ul></div></li></ul></li>
      </ul>
    </header>
    <main>
      <div class='section no-pad-bot' id='index-banner'>
        <div class='container'>
          <h1 class='header center-on-small-only'>NewFeatures</h1>
          <div class='row center'>
          </div>
          
        </div>
        
      </div>
      <div class='container'>
        <p><em>New Features added to this open source release of Aparapi. Updated Sep 14, 2011 by frost.g&hellip;@gmail.com</em></p>
        
        <h2>New Features</h2>
        
        <p>Aparapi has two new, especially useful features:</p>
        
        <p>Explicit Buffer Management for minimizing buffer transfers
        Kernel access to objects held in arrays</p>
        
        <h3>Minimizing Buffer Transfers</h3>
        
        <h4>Explicit Buffer Management</h4>
        
        <p>Aparapi is designed to shield the Java developer from dealing with the underlying movement of data between the OpenCL host and device. Aparapi can analyze a kernel&rsquo;s run() method and run-reachable methods to determine which primitive arrays to transfer to the GPU prior to execution, and which arrays to transfer back when the GPU execution is complete.</p>
        
        <p>Generally this strategy is both clean and performant. Aparapi will attempt to just do the right thing.</p>
        
        <p>However, occasionally the following code pattern is seen.</p>
        <pre class="highlight plaintext"><code>final int[] hugeArray = new int[HUGE];
        final int[] done = new int[]{0};
        Kernel kernel= new Kernel(){
           ... // reads/writes hugeArray and writes to done[0] when complete
        };
        done[0]=0;
        while (done[0] ==0)){
           kernel.execute(HUGE);
        }
        </code></pre>
        <p>This is a common pattern in reduce stages of map-reduce type problems. Essentially the developer wants to keep executing a kernel until some condition is met. For example, this may be seen in bitonic sort implementations and various financial applications.</p>
        
        <p>From the code it can be seen that the kernel reads and writes hugeArray[] array and uses the single item done[] array to indicate some form of convergence or completion.</p>
        
        <p>Unfortunately, by default Aparapi will transfer done[] and hugeArray[] to and from the GPU device each time Kernel.execute(HUGE) is executed.</p>
        
        <p>To demonstrate which buffers are being transfered, these copies are shown as comments in the following version of the code.</p>
        <pre class="highlight plaintext"><code>final int[] hugeArray = new int[HUGE];
        final int[] done = new int[]{0};
        Kernel kernel= new Kernel(){
           ... // reads/writes hugeArray and writes to done[0] when complete
        };
        done[0]=0;
        while (done[0] ==0)){
           // Send done[] to GPU
           // Send hugeArray[] to GPU
           kernel.execute(HUGE);
           // Fetch done[] from GPU
           // Fetch hugeArray[] from GPU
        }
        </code></pre>
        <p>Further analysis of the code reveals that hugeArray[] is not accessed by the loop containing the kernel execution, so Aparapi is performing 999 unnecessary transfers to the device and 999 unnecessary transfers back. Only two transfers of hugeArray[] are needed; one to move the initial data to the GPU and one to move it back after the loop terminates.</p>
        
        <p>The done[] array is accessed during each iteration (although never written to within the loop), so it does needs to be transferred back for each return from Kernel.execute(), however, it only needs to be sent once.</p>
        
        <p>Clearly it is better to avoid unnecessary transfers, especially of large buffers like hugeArray[].</p>
        
        <p>A new Aparapi feature allows the developer to control these situations and explicitly manage transfers.</p>
        
        <p>To use this feature first set the mode to explicit, using the kernel.setExplicit(true) method, and then requests transfers using either kernel.put() or kernel.get(). Kernel.put() forces a transfer to the GPU device and Kernel.get() transfers data back.</p>
        
        <p>The following code illustrates the use of these new explicit buffer management APIs.</p>
        <pre class="highlight plaintext"><code>final int[] hugeArray = new int[HUGE];
        final int[] done = new int[]{0};
        Kernel kernel= new Kernel(){
           ... // reads/writes hugeArray and writes to done[0] when complete
        };
        kernel.setExplicit(true);
        done[0]=0;
        kernel.put(done);
        kernel.put(hugeArray);
        while (done[0] ==0)){
           kernel.execute(HUGE);
           kernel.get(done);
        }
        kernel.get(hugeArray);
        </code></pre>
        <p>Note that marking a kernel as explicit and failing to request the appropriate transfer is a programmer error.</p>
        
        <p>We deliberately made Kernel.put(…), Kernel.get(…) and Kernel.execute(range) return an instance of the executing kernel to allow these calls be chained. Some may find this fluent style API more expressive.</p>
        <pre class="highlight plaintext"><code>final int[] hugeArray = new int[HUGE];
        final int[] done = new int[]{0};
        Kernel kernel= new Kernel(){
           ... // reads/writes hugeArray and writes to done[0] when complete
        };
        kernel.setExplicit(true);
        done[0]=0;
        kernel.put(done).put(hugeArray);    // chained puts
        while (done[0] ==0)){
           kernel.execute(HUGE).get(done);  // chained execute and put
        }
        kernel.get(hugeArray);
        </code></pre>
        <h4>An alternate approach for loops containing a single kernel.execute(range) call.</h4>
        
        <p>One variant of code which would normally suggest the use of Explicit Buffer Management can be handled differently. For cases where Kernel.execute(range) is the sole statement inside a loop and where the iteration count is known prior to the first iteration we offer an alternate (hopefully more elegant) way of minimizing buffer transfers.</p>
        
        <p>So for cases like:-</p>
        <pre class="highlight plaintext"><code>final int[] hugeArray = new int[HUGE];
        Kernel kernel= new Kernel(){
           ... // reads/writes hugeArray
        };
        
        for (int pass=0; pass&lt;1000; pass++){
           kernel.execute(HUGE);
        }
        </code></pre>
        <p>The developer can request that Aparapi perform the outer loop rather than coding the loop. This is achieved explicitly by passing the iteration count as the second argument to Kernel.execute(range, iterations).</p>
        
        <p>Now any form of code that looks like :-</p>
        <pre class="highlight plaintext"><code>int range=1024;
        int loopCount=64;
        for (int passId=0; passId&lt;loopCount; passId++){
           kernel.execute(range);
        }
        </code></pre>
        <p>Can be replaced with</p>
        <pre class="highlight plaintext"><code>int range=1024;
        int loopCount=64;
        
        kernel.execute(range, loopCount);
        </code></pre>
        <p>Not only does this make the code more compact and avoids the use of explicit buffer management APIs, it allows Aparapi visibility to the complete loop so that Aparapi can minimize the number of transfers. Aparapi will only transfer buffers to the GPU once and transfer them back once, resulting in improved performance.</p>
        
        <p>Sometimes kernel code using this loop-pattern needs to track the current iteration number as the code passed through the outer loop. Previously we would be forced to use explicit buffer management to allow the kernel to do this.</p>
        
        <p>The code for this would have looked something like</p>
        <pre class="highlight plaintext"><code>int range=1024;
        int loopCount=64;
        final int[] hugeArray = new int[HUGE];
        final int[] passId = new int[0];
        Kernel kernel= new Kernel(){
           @Override public void run(){
              int id=getGlobalId();
              if (passId[0] == 0){
                  // perform some initialization!
              }
              ... // reads/writes hugeArray
           }
        };
        Kernel.setExplicit(true);
        kernel.put(hugeArray);
        for (passId[0]=0; passId[0]&lt;loopCount; passId[0]++){
        
           kernel.put(passId).execute(range);
        }
        </code></pre>
        <p>In the current version of Aparapi we added Kernel.getPassId() to allow a Kernel to determine the current ‘pass’ through the outer loop without having to use explicit buffer management.</p>
        
        <p>So the previous code can now be written without any explicit buffer management APIs:-</p>
        <pre class="highlight plaintext"><code>final int[] hugeArray = new int[HUGE];
        final int[] pass[] = new int[]{0};
        Kernel kernel= new Kernel(){
           @Override public void run(){
              int id=getGlobalId();
              int pass = getPassId();
              if (pass == 0){
                  // perform some initialization!
              }
              ... // reads/writes both hugeArray
           }
        };
        
        kernel.execute(HUGE, 1000);
        </code></pre>
        <p>One common use for Kernel.getPassId() is to avoid flipping buffers in the outer loop.</p>
        
        <p>It is common for kernels to process data from one buffer to another, and in the next invocation process the data back the other way. Now these kernels can use the passId (odd or even) to determine the direction of data transfer.</p>
        <pre class="highlight plaintext"><code>final int[] arr1 = new int[HUGE];
        final int[] arr2 = new int[HUGE];
        Kernel kernel= new Kernel(){
           int f(int v){ … }
        
           @Override public void run(){
              int id=getGlobalId();
              int pass = getPassId();
              if (pass%2==0){
                  arr1[id] = f(arr2[id]);
              }else{
                  arr2[id] = f(arr1[id]);
        
              }
           }
        };
        
        kernel.execute(HUGE, 1000);
        </code></pre>
        <h4>Allow kernels to access simple arrays of objects</h4>
        
        <p>Aparapi needs to create OpenCL from the bytecode that it sees. Generally OpenCL constrains us to using parallel primitive arrays (OpenCL allows structs, but Java and OpenCL do not have comparable memory layouts for these structures). Therefore, you will generally need to refactor your code from a classic object-oriented form to use primitive arrays.</p>
        
        <p>This incompatibility between data-parallel and object-oriented code patterns might discourage use of Aparapi, so Aparapi includes limited support for arrays of simple Objects. Future versions may well extend this functionality and address performance loss.</p>
        
        <p>Consider the NBody example.</p>
        
        <p>Typically, a Java developer writing NBody would probably not separate the x,y and z ordinates into parallel arrays of floats as was required in the previous (alpha) version of Aparapi. Instead, a Java developer would probably create a Body class to hold the state of each body and possibly a Universe class (container of Body instances) with the responsible for positioning and possibly displaying the bodies.</p>
        <pre class="highlight plaintext"><code>class Body{
          float x,y,z;
          float getX(){return x;}
          void setX(float _x){ x = _x;}
          float getY(){return y;}
          void setY(float _y){ y = _y;}
          float getZ(){return z;}
          void setZ(float _z){ z = _z;}
        
        
          // other data related to Body unused by positioning calculations
        }
        
        class Universe{
             final Body[] bodies;
             public Universe(final Body[] _bodies){
                bodies = _bodies;
             }
             void adjustPositions(){
                 for (Body outer:bodies){
                    for (Body inner:bodies}{
                       // adjust outer position to reflect the effect of inner
                       // using inner and outer getters and setters for x, y and z
                    }
                 }
             }
             void display(){
                for (Body body:bodies){
                   // draw body based on x, y and z using Body getters
                }
             }
        }
        </code></pre>
        <p>From the above code we see that the Universe.adjustPositions() method is compute intensive and an ideal candidate for refactoring to use Aparapi. The current version of Aparapi is able to deal with simple arrays of objects like this.</p>
        
        <p>Now when Aparapi encounters an array of objects and the accesses to these objects are constrained to simple getters and setters, Aparapi will automatically extract the values of the accessed fields into a data parallel form, execute the kernel and then replace the results back in the original objects in the array. This happens on each call to Kernel.execute() and is fairly costly (from a performance point of view), however, for embarrassingly parallel code (such as NBody), we can still show considerable performance gains over standard Java Thread Pool</p>
        
        <p>Attribution</p>
      </div>
    </main>
    <footer class='page-footer'>
      <div class='container'>
        <div class='row'>
          <div class='col l4 s12'>
            <h5 class='white-text'>Help Aparapi Grow</h5>
            <p class='grey-text text-lighten-4'>We are a team of volunteers working on this project like it's our full time job. Any amount would help support and continue development on this project and is greatly appreciated.</p>
            <form action='https://www.paypal.com/cgi-bin/webscr' id='paypal-donate' method='post' target='_top'>
              <input name='cmd' type='hidden' value='_s-xclick'>
              <input name='encrypted' type='hidden' value='-----BEGIN PKCS7-----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-----END PKCS7-----'>
              <button alt='PayPal - The safer, easier way to pay online!' class='btn waves-effect waves-light red lighten-3' name='action' type='submit'>
                Donate Now
              </button>
            </form>
          </div>
          <div class='col l4 s12'>
            <h5 class='white-text'>Join the Discussion</h5>
            <p class='grey-text text-lighten-4'>We have a Gitter chat room set up where you can talk directly with us. Come in and discuss new features, future goals, general problems or questions, or anything else you can think of.</p>
            <a class='btn waves-effect waves-light red lighten-3' href='https://gitter.im/Syncleus/aparapi' target='_blank'>Chat</a>
          </div>
          <div class='col l4 s12' style='overflow: hidden;'>
            <h5 class='white-text'>Connect</h5>
            <iframe allowtransparency='true' frameborder='0' height='30' scrolling='0' src='http://ghbtns.com/github-btn.html?user=Syncleus&amp;repo=aparapi&amp;type=watch&amp;count=true&amp;size=large' width='170'></iframe>
            <br>
            <a class='twitter-follow-button' data-dnt='true' data-show-count='true' data-size='large' href='https://twitter.com/AparapiLib'>Follow @AparapiLib</a>
            <br>
            <div class='g-follow' data-annotation='bubble' data-height='24' data-href='https://plus.google.com/102266131584900704956' data-rel='publisher'></div>
          </div>
        </div>
      </div>
      <div class='footer-copyright'>
        <div class='container'>
          © 2016-2017 Syncleus, All rights reserved.
          <a class='grey-text text-lighten-4 right' href='https://github.com/Syncleus/aparapi/blob/master/LICENSE'>Apache License v2</a>
        </div>
      </div>
    </footer>
    <!-- Scripts -->
    <script src='https://code.jquery.com/jquery-2.1.4.min.js'></script>
    <script>
      if (!window.jQuery) { document.write('<script src="bin/jquery-2.1.1.min.js"><\/script>'); }
    </script>
    <script src='/javascripts/jquery.timeago.js'></script>
    <script src='/javascripts/materialize.min.js'></script>
    <script src='/javascripts/lunr.min.js'></script>
    <script src='/javascripts/search.js'></script>
    <script src='/javascripts/materialize.js'></script>
    <script src='/javascripts/init.js'></script>
    <!-- Twitter Button -->
    <script>
      !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
    </script>
    <!-- Google Plus Button -->
    <script async='' defer='defer' src='https://apis.google.com/js/platform.js'></script>
  </body>
</html>
