<!DOCTYPE html>
<html lang='en'>
<head>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<meta content='width=device-width, initial-scale=1' name='viewport'>
<meta content='IE=edge' http-equiv='X-UA-Compatible'>
<meta content='no' name='msapplication-tap-highlight'>
<meta content='Aparapi is an Open-source framework for executing native Java code on the GPU, developed by Syncleus.' name='description'>
<title>
Aparapi | Explicit Buffer Handling
</title>
<!-- Favicons -->
<link href='/images/favicon/apple-touch-icon-152x152.png' rel='apple-touch-icon-precomposed'>
<meta content='#FFFFFF' name='msapplication-TileColor'>
<meta content='/images/favicon/mstile-144x144.png' name='msapplication-TileImage'>
<link href='/images/favicon/favicon-32x32.png' rel='icon' sizes='32x32'>
<!-- Android 5 Chrome Color -->
<meta content='#EE6E73' name='theme-color'>
<!-- CSS -->
<link href='/stylesheets/highlight.css' media='screen,projection' rel='stylesheet' type='text/css'>
<link href='/stylesheets/style.css' media='screen,projection' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/icon?family=Material+Icons' rel='stylesheet'>
</head>
<body>
<header>
<div class='container'>
<a class='button-collapse top-nav waves-effect waves-light circle hide-on-large-only' data-activates='nav-mobile' href='#'>
<i class='material-icons'>menu</i>
</a>
</div>
<ul class='side-nav fixed' id='nav-mobile'>
<li class='logo'>
<a class='brand-logo' href='/' id='logo-container'>
<object data='/images/logo.svg' id='front-page-logo' type='image/svg+xml'>Your browser does not support SVG</object>
</a>
</li>
<li class='search'>
<div class='search-wrapper card'>
<input id='search'>
<i class='material-icons'>search</i>
<div class='search-results'></div>
</div>
</li>
<li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/">Overview</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a class='collapsible-header waves-effect waves-teal'>Introduction</a><div class='collapsible-body'><ul><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/introduction/about.html">About</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/introduction/getting-started.html">Getting Started</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/introduction/faq.html">FAQ</a></li></ul></li></ul></div></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a class='collapsible-header waves-effect waves-teal'>Documentation</a><div class='collapsible-body'><ul><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/aparapi-patterns.html">Aparapi Patterns</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/choosing-specific-devices.html">Choosing Specific Devices</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/converting-java-to-opencl.html">Converting Java to OpenCL</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/emulating-multiple-entrypoints.html">Emulating Multiple Entrypoints</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/explicit-buffer-handling.html">Explicit Buffer Handling</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/hsa-enabled-lambda.html">HSA Enabled Lambda</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/kernel-guidelines.html">Kernel Guidelines</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/library-agent-duality.html">Library Agent Duality</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/new-features.html">New Features</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/opencl-bindings.html">OpenCL Bindings</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/private-memory-space.html">Private Memory Space</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/profiling-the-kernel.html">Profiling the Kernel</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/setting-up-hsa.html">Setting Up HSA</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/unit-tests.html">Unit Tests</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/using-hsa-simulator.html">Using HSA Simulator</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/constant-memory.html">Constant Memory</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/local-memory.html">Local Memory</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/documentation/multiple-dim-ranges.html">Multiple Dim Ranges</a></li></ul></li></ul></div></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a class='collapsible-header waves-effect waves-teal'>Proposals</a><div class='collapsible-body'><ul><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/multiple-dim-nd-range.html">Multiple Dim ND Range</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/lambdas.html">Lambdas</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/address-space-with-buffers.html">Address Space with Buffers</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/extensions.html">Extensions</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/device.html">Device</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/multiple-entry-points.html">Multiple Entry Points</a></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/proposals/lambda-syntax.html">Lambda Syntax</a></li></ul></li></ul></div></li></ul></li><li class='no-padding'><ul class='collapsible collapsible-accordion'><li class='bold'><a href="/showcase.html">Showcase</a></li></ul></li>
</ul>
</header>
<main>
<div class='section no-pad-bot' id='index-banner'>
<div class='container'>
<h1 class='header center-on-small-only'>Explicit Buffer Handling</h1>
<div class='row center'>
<h4 class='header col s12 light center'>How to minimize buffer transfers.</h4>
</div>

</div>

</div>
<div class='container'>
<p>Aparapi is designed to shield the Java developer from dealing with the underlying movement of data between the OpenCL host and device. Aparapi can analyze a kernel&rsquo;s <code>run()</code> method and run-reachable methods to determine which primitive arrays to transfer to the GPU prior to execution, and which arrays to transfer back when the GPU execution is complete.</p>

<p>Generally this strategy is both clean and performant. Aparapi will attempt to just do the right thing.</p>

<p>However, occasionally the following code pattern is seen.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
    <span class="o">...</span> <span class="c1">// reads/writes hugeArray</span>
<span class="o">};</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">loop</span> <span class="o">&lt;</span><span class="n">MAXLOOP</span><span class="o">;</span> <span class="n">loop</span><span class="o">++){</span>
    <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>This is a common pattern which unfortunately exposes an issue with Aparapi&rsquo;s normal buffer handling.</p>

<p>Although Aparapi does analyze the byte code of the <code>Kernel.run()</code> method (and any method reachable from <code>Kernel.run()</code>) Aparapi has no visibility to the call site. In the above code there is no way for Aparapi to detect that that hugeArray is not modified within the for loop body. Unfortunately, Aparapi must default to being &lsquo;safe&rsquo; and copy the contents of hugeArray backwards and forwards to the GPU device.</p>

<p>Here we add comments to indicate where the unnecessary buffer transfers take place.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="o">...</span> <span class="c1">// reads/writes hugeArray</span>
<span class="o">};</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">loop</span> <span class="o">&lt;</span><span class="n">MAXLOOP</span><span class="o">;</span> <span class="n">loop</span><span class="o">++){</span>
   <span class="c1">// copy hugeArray to GPU</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
   <span class="c1">// copy hugeArray back from the GPU</span>
<span class="o">}</span>
</code></pre></div>
<p>In reality hugeArray only needs to be copied to the GPU once (prior to the loop) and then once again when the loop has terminated.</p>

<p>Here we use comments to indicated the &lsquo;optimal&rsquo; transfers.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="o">...</span> <span class="c1">// reads/writes hugeArray</span>
<span class="o">};</span>
<span class="c1">// Ideally transfer hugeArray to GPU here</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">loop</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">loop</span> <span class="o">&lt;</span><span class="n">MAXLOOP</span><span class="o">;</span> <span class="n">loop</span><span class="o">++){</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// Ideally transfer hugeArray back from GPU here</span>
</code></pre></div>
<p>Consider another common pattern</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">done</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">};</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="o">...</span> <span class="c1">// reads/writes hugeArray and writes to done[0] when complete</span>
<span class="o">};</span>
<span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span><span class="mi">0</span><span class="o">)){</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>This is a common pattern in reduce stages of map-reduce type problems. Essentially the developer wants to keep executing a kernel until some condition is met. For example, this may be seen in bitonic sort implementations and various financial applications.</p>

<p>From the code it can be seen that the kernel reads and writes <code>hugeArray[]</code> array and uses the single item <code>done[]</code> array to indicate some form of convergence or completion.</p>

<p>As we demonstrated above, by default Aparapi will transfer <code>done[]</code> and <code>hugeArray[]</code> to and from the GPU device each time <code>Kernel.execute(HUGE)</code> is executed.</p>

<p>To demonstrate which buffers are being transfered, these copies are shown as comments in the following version of the code.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">done</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">};</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="o">...</span> <span class="c1">// reads/writes hugeArray and writes to done[0] when complete</span>
<span class="o">};</span>
<span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
<span class="k">while</span> <span class="o">(</span><span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span><span class="mi">0</span><span class="o">)){</span>
   <span class="c1">// Send done[] to GPU</span>
   <span class="c1">// Send hugeArray[] to GPU</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
   <span class="c1">// Fetch done[] from GPU</span>
   <span class="c1">// Fetch hugeArray[] from GPU</span>
<span class="o">}</span>
</code></pre></div>
<p>Further analysis of the code reveals that <code>hugeArray[]</code> is not accessed by the loop containing the kernel execution, so Aparapi is performing 999 unnecessary transfers to the device and 999 unnecessary transfers back. Only two transfers of <code>hugeArray[]</code> are needed; one to move the initial data to the GPU and one to move it back after the loop terminates.</p>

<p>The <code>done[]</code> array is accessed during each iteration (although never written to within the loop), so it does need to be transferred back for each return from Kernel.execute(), however, it only needs to be sent once.</p>

<p>Clearly it is better to avoid unnecessary transfers, especially of large buffers like <code>hugeArray[]</code>.</p>

<p>Aparapi exposes a feature which allows the developer to control these situations and explicitly manage transfers.</p>

<p>To use this feature first the developer needs to &lsquo;turn on&rsquo; explicit mode, using the <code>kernel.setExplicit(true)</code> method. Then the developer can request buffer/array transfers using either <code>kernel.put()</code> or <code>kernel.get()</code>. <code>Kernel.put()</code> forces a transfer to the GPU device and Kernel.get() transfers data back.</p>

<p>The following code illustrates the use of these new explicit buffer management APIs.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">done</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">};</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="o">...</span> <span class="c1">// reads/writes hugeArray and writes to done[0] when complete</span>
<span class="o">};</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">setExplicit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">done</span><span class="o">);</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">hugeArray</span><span class="o">);</span>
<span class="k">while</span> <span class="o">(</span><span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span><span class="mi">0</span><span class="o">)){</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">done</span><span class="o">);</span>
<span class="o">}</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">hugeArray</span><span class="o">);</span>
</code></pre></div>
<p>Note that marking a kernel as explicit and failing to request the appropriate transfer is a programmer error.</p>

<p>We deliberately made <code>Kernel.put(...)</code>, <code>Kernel.get(...)</code> and <code>Kernel.execute(range)</code> return an instance of the executing kernel to allow these calls be chained. Some may find this fluent style API more expressive.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">done</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">};</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="o">...</span> <span class="c1">// reads/writes hugeArray and writes to done[0] when complete</span>
<span class="o">};</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">setExplicit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">done</span><span class="o">).</span><span class="na">put</span><span class="o">(</span><span class="n">hugeArray</span><span class="o">);</span>    <span class="c1">// chained puts</span>
<span class="k">while</span> <span class="o">(</span><span class="n">done</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span><span class="mi">0</span><span class="o">)){</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">).</span><span class="na">get</span><span class="o">(</span><span class="n">done</span><span class="o">);</span>  <span class="c1">// chained execute and put</span>
<span class="o">}</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">hugeArray</span><span class="o">);</span>
</code></pre></div>
<p>An alternate approach for loops containing a single <code>kernel.execute(range)</code> call.
One variant of code which would normally suggest the use of Explicit Buffer Management can be handled differently. For cases where <code>Kernel.execute(range)</code> is the sole statement inside a loop and where the iteration count is known prior to the first iteration we offer an alternate (hopefully more elegant) way of minimizing buffer transfers.</p>

<p>So for cases like:-</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="n">Kernel</span> <span class="n">kernel</span><span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
    <span class="o">...</span> <span class="c1">// reads/writes hugeArray</span>
<span class="o">};</span>

<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">pass</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">pass</span><span class="o">&lt;</span><span class="mi">1000</span><span class="o">;</span> <span class="n">pass</span><span class="o">++){</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>The developer can request that Aparapi perform the outer loop rather than coding the loop. This is achieved explicitly by passing the iteration count as the second argument to <code>Kernel.execute(range, iterations)</code>.</p>

<p>Now any form of code that looks like :-</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">loopCount</span> <span class="o">=</span> <span class="mi">64</span><span class="o">;</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">passId</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">passId</span> <span class="o">&lt;</span> <span class="n">loopCount</span><span class="o">;</span> <span class="n">passId</span><span class="o">++){</span>
   <span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">range</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>Can be replaced with</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">loopCount</span> <span class="o">=</span> <span class="mi">64</span><span class="o">;</span>

<span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">range</span><span class="o">,</span> <span class="n">loopCount</span><span class="o">);</span>
</code></pre></div>
<p>Not only does this make the code more compact and avoids the use of explicit buffer management APIs, it allows Aparapi visibility to the complete loop so that Aparapi can minimize the number of transfers. Aparapi will only transfer buffers to the GPU once and transfer them back once, resulting in improved performance.</p>

<p>Sometimes kernel code using this loop-pattern needs to track the current iteration number as the code passed through the outer loop. Previously we would be forced to use explicit buffer management to allow the kernel to do this.</p>

<p>The code for this would have looked something like</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kt">int</span> <span class="n">range</span> <span class="o">=</span> <span class="mi">1024</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">loopCount</span> <span class="o">=</span> <span class="mi">64</span><span class="o">;</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">passId</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
<span class="n">Kernel</span> <span class="n">kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
      <span class="kt">int</span> <span class="n">id</span><span class="o">=</span><span class="n">getGlobalId</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">passId</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
          <span class="c1">// perform some initialization!</span>
      <span class="o">}</span>
      <span class="o">...</span> <span class="c1">// reads/writes hugeArray</span>
   <span class="o">}</span>
<span class="o">};</span>
<span class="n">Kernel</span><span class="o">.</span><span class="na">setExplicit</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">kernel</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">hugeArray</span><span class="o">);</span>
<span class="k">for</span> <span class="o">(</span><span class="n">passId</span><span class="o">[</span><span class="mi">0</span><span class="o">]=</span><span class="mi">0</span><span class="o">;</span> <span class="n">passId</span><span class="o">[</span><span class="mi">0</span><span class="o">]&lt;</span><span class="n">loopCount</span><span class="o">;</span> <span class="n">passId</span><span class="o">[</span><span class="mi">0</span><span class="o">]++){</span>

   <span class="n">kernel</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">passId</span><span class="o">).</span><span class="na">execute</span><span class="o">(</span><span class="n">range</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div>
<p>In the current version of Aparapi we added <code>Kernel.getPassId()</code> to allow a Kernel to determine the current ‘pass’ through the outer loop without having to use explicit buffer management.</p>

<p>So the previous code can now be written without any explicit buffer management APIs:-</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">hugeArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">pass</span><span class="o">[]</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">};</span>
<span class="n">Kernel</span> <span class="n">kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
      <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">getGlobalId</span><span class="o">();</span>
      <span class="kt">int</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">getPassId</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">pass</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
          <span class="c1">// perform some initialization!</span>
      <span class="o">}</span>
      <span class="o">...</span> <span class="c1">// reads/writes both hugeArray</span>
   <span class="o">}</span>
<span class="o">};</span>

<span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
</code></pre></div>
<p>One common use for Kernel.getPassId() is to avoid flipping buffers in the outer loop.</p>

<p>It is common for kernels to process data from one buffer to another, and in the next invocation process the data back the other way. Now these kernels can use the passId (odd or even) to determine the direction of data transfer.</p>
<div class="highlight"><pre class="highlight java"><code>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="kd">final</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">HUGE</span><span class="o">];</span>
<span class="n">Kernel</span> <span class="n">kernel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Kernel</span><span class="o">(){</span>
   <span class="kt">int</span> <span class="nf">f</span><span class="o">(</span><span class="kt">int</span> <span class="n">v</span><span class="o">){</span> <span class="err">…</span> <span class="o">}</span>

   <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">(){</span>
      <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">getGlobalId</span><span class="o">();</span>
      <span class="kt">int</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">getPassId</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">pass</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">){</span>
          <span class="n">arr1</span><span class="o">[</span><span class="n">id</span><span class="o">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">arr2</span><span class="o">[</span><span class="n">id</span><span class="o">]);</span>
      <span class="o">}</span><span class="k">else</span><span class="o">{</span>
          <span class="n">arr2</span><span class="o">[</span><span class="n">id</span><span class="o">]</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">arr1</span><span class="o">[</span><span class="n">id</span><span class="o">]);</span>

      <span class="o">}</span>
   <span class="o">}</span>
<span class="o">};</span>

<span class="n">kernel</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">HUGE</span><span class="o">,</span> <span class="mi">1000</span><span class="o">);</span>
</code></pre></div>
</div>
</main>
<footer class='page-footer'>
<div class='container'>
<div class='row'>
<div class='col l4 s12'>
<h5 class='white-text'>Help Aparapi Grow</h5>
<p class='grey-text text-lighten-4'>We are a team of volunteers working on this project like it's our full time job. Any amount would help support and continue development on this project and is greatly appreciated.</p>
<form action='https://www.paypal.com/cgi-bin/webscr' id='paypal-donate' method='post' target='_top'>
<input name='cmd' type='hidden' value='_s-xclick'>
<input name='hosted_button_id' type='hidden' value='EGPN4CSPCW9JN'>
<button alt='PayPal - The safer, easier way to pay online!' class='btn waves-effect waves-light red lighten-3' name='action' type='submit'>
Donate Now
</button>
</form>
</div>
<div class='col l4 s12'>
<h5 class='white-text'>Join the Discussion</h5>
<p class='grey-text text-lighten-4'>We have a Gitter chat room set up where you can talk directly with us. Come in and discuss new features, future goals, general problems or questions, or anything else you can think of.</p>
<a class='btn waves-effect waves-light red lighten-3' href='https://gitter.im/Syncleus/aparapi' target='_blank'>Chat</a>
</div>
<div class='col l4 s12' style='overflow: hidden;'>
<h5 class='white-text'>Connect</h5>
<iframe allowtransparency='true' frameborder='0' height='30' scrolling='0' src='http://ghbtns.com/github-btn.html?user=Syncleus&amp;repo=aparapi&amp;type=watch&amp;count=true&amp;size=large' width='170'></iframe>
<br>
<a class='twitter-follow-button' data-dnt='true' data-show-count='true' data-size='large' href='https://twitter.com/AparapiLib'>Follow @AparapiLib</a>
<br>
<div class='g-follow' data-annotation='bubble' data-height='24' data-href='https://plus.google.com/102266131584900704956' data-rel='publisher'></div>
</div>
</div>
</div>
<div class='footer-copyright'>
<div class='container'>
© 2016-2017 Syncleus, All rights reserved.
<a class='grey-text text-lighten-4 right' href='https://github.com/Syncleus/aparapi/blob/master/LICENSE'>Apache License v2</a>
</div>
</div>
</footer>
<!-- Scripts -->
<script src='https://code.jquery.com/jquery-2.1.4.min.js'></script>
<script>
  if (!window.jQuery) { document.write('<script src="bin/jquery-2.1.1.min.js"><\/script>'); }
</script>
<script src='/javascripts/jquery.timeago.js'></script>
<script src='/javascripts/materialize.min.js'></script>
<script src='/javascripts/lunr.min.js'></script>
<script src='/javascripts/search.js'></script>
<script src='/javascripts/materialize.js'></script>
<script src='/javascripts/init.js'></script>
<!-- Twitter Button -->
<script>
  !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
</script>
<!-- Google Plus Button -->
<script async='' defer='defer' src='https://apis.google.com/js/platform.js'></script>
</body>
</html>
